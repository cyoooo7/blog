---
title: 读书笔记 - 《.Net设计规范 - 约定、惯用法与模式》
author: Roy Cheng
date: 2018-01-03 13:10
template: article.jade
---

/原作者: Krzysztof Cwalina & Brad Abrams/

<span class="more"></span>

## 第1章·概述
* 如果框架的设计者能够站在其使用者背后解释应该如何使用框架，那么规范就没有存在的必要了。
* 精心设计的框架是简单的。
* 大多数框架并不缺乏强大的功能，这是因为随着需求变得更加清晰，增加更多的特性是相当容易的事情。
* 精心设计的框架设计代价高。
* 精心设计的框架充满权衡利弊
* 要让API尽可能地无趣。有趣的应该是功能，而不是API。
* 精心设计的框架要考虑未来发展。
* 精心设计的框架应具有良好的集成性。
* 现代框架需要有适当的工具来支持，也应该与开发者社区所使用的编程语言相集成。
* 精心设计的框架是一致的。
* 一致的框架可以让开发人员举一反三，从框架中以了解的部分推知不了解的部分。

## 第2章·框架设计基础
* 一个成功的通用框架必须是为广大具有不同需求、技能和背景的开发人员而设计的。
* 框架设计师面临的最大挑战之一就是为这些多样化的用户提供既简单又功能强大的框架。
* 在设计框架时应该把注意力集中在一些常用场景，使整个设计过程围绕使用场景来进行。
* 框架必须以易于实验的方式来为普通用户提供一个低门槛。
	* 要确保每个主要特性域的名字空间只包含那些用于最常见场景的类型。应该把用于更高级场景的类型放在子名字空间中。
	* 要为构造函数和方法提供简单的重载函数。一个简单的重载函数的参数应该非常少，而且所有的参数都是基本类型。
	* 不要要求用户在最基本的场景中显示地实例化一个以上的类型。
* 把最好的名字留给最常用的类型。
	* 争取让处于某个场景的用户在第一时间猜到他应该使用的类型的名字。
* 避免在主要场景的API中使用太多的抽象。
	* 抽象技术是必须的，但抽象太多则是系统设计过度象征。
* 对框架进行分层，使高层API能提供最佳的开发效率，低层API能提供最强大的功能。

## 第3章·命名规范
* 要把两个字母的首字母缩写词全部大写。例如System.IO。
	* 但两个例外的单词是Ok和Id，原因在于，它们是俚语性质的常用缩写。
* 名字空间的一般规则：`<Company>.(<Product>|<Technology>)[.<Feature>][.<subnamespace>]` 
* 用单数名词来命名非bit field枚举类型，用复数名词来命名bit field枚举类型。例如：
```c#
public enum ConsoleColor
{
    Black, 
    Read,
    ...
}
[Flags]
public enum ConsoleModifiers
{
    Alt, 
    Shift,
    ...
}
```

* 在为一个布尔属性和布尔函数命名时，考虑用一个if语句来测试命名是否通顺。例如：`if(collection.Contains(item))` 和 `if(regulaExpression.Matches(text))` 读起来比 `if(collection.IsContained(item))` 和 `if(regulaExpression.Match(text))
` 更自然。

## 第4章·类型设计规范
* 用名字空间把类型组织到层次结构中。该层次结构应该让开发人员更容易地浏览框架并找到想要的API。
	* 名字空间的主要目的不是为了帮助同名类型之间的名字冲突，而是为了把类型组织成一个有条理、易于浏览、易于理解的层次结构。
* 如果类型的实例比较小而且生命周期比较短，或者经常被内嵌在其他对象中，考虑将其定义为结构而不是类。
* 除非类型具有以下特征，否则不要定义结构：
	* 它在逻辑上代表一个独立的值，与基本类型（int,double等等）相似。
	* 他的实例的大小小于16个字节。
	* 它是不可变的。
	* 它不需要经常被装箱。
* 接口的主要缺点在于，如果想让API逐步演化，那么它的灵活性不如类。一旦发布了一个接口，它的成员就永远固定了。给接口添加任何东西都会破坏实现了该接口的已有类型。
* 接口的优势在于，可以通过定义接口来达到与多重继承类似的效果。
* 静态类是在纯面向对象和简单性之间的一个权衡。
	* 静态类被广泛用来提供一些访问其他操作的快捷方式，存放扩展方法，以一种不完全面向对象的方式来提供一些功能。
	* 要尽量少用静态类，不要把静态类当作杂物箱。
	* 静态类应该仅被用作辅助类。
	* 每一个静态类都应该有其明确的目的。
* 不要定义可变的值类型。
	* 可变的值类型存在诸多问题。例如，如果getter属性返回的是一个值类型，那么调用者得到的是一个副本。由于是隐式的创建副本，因此 开发人员可能不会意识到他们修改的是一个副本，而不是原来的值。
* 要确保当结构实例的所有数据都为0、false或null（如果合适）时，结构仍处于有效状态。
	* 这可以避免在创建一个该结构的数组时创建出无效的实例。
* 要为值类型实现 `IEquatable<T>`接口。
	* 值类型的 `Object.Equels` 方法会导致装箱，而且因为它使用了反射，所以它的默认实现也并不高效。
* 要在包含公共类型的程序集中使用AssemblyVersionAttribute特性。
	* 考虑在程序集版本号中使用`<V>.<S>.<B>.<R>`的格式。其中V是主版本号，S是服务版本号，B是构建号，R是构建修订号。

## 第5章·成员设计
* 避免在重载中随意地改变参数的名字。如果两个重载中的某个参数表示相同的输入，那么该参数的名字应该在两个重载中保持一致。
* 避免使重载成员的参数顺序不一致。在所有的重载中，同名参数应该出现在相同的位置。
* 如果需要可扩展性，应该把最长的重载成员定义成重载成员中唯一的虚成员。较短的重载应该只是调用一下较长的重载。
* 要优先使用成员重载，而不是定义有默认参数的成员。默认参数不符合CLS规范。
* 在设计类型的成员时,程序库设计师最常面临的抉择之一就是到底应该吧成员设计为属性还是方法。请在下列情况中使用方法而不要使用属性：
	* 操作比字段访问要慢几个数量级。
	* 该操作是一个转换操作，比如Object.ToString方法。
	* 该操作在每次调用时都返回不同的结果。
	* 该操作有严重的、显而易见的副作用。（一般不把填充内部缓存视为显而易见的副作用。）
	* 该操作返回内部状态的一个副本（这不包括那些在栈上返回的值类型对象的副本）。
	* 该操作返回一个数组。
* 要允许用户以任何顺序设置属性的值，即使这可能会使对象在短时间内处于无效状态。
	* 两个或两个以上的属性之间相互关联是很正常的，很可能一个属性的某些值与其他属性的某些值组合在一起是无效的。在这种情况下，应该推迟抛出由于状态无效而导致的异常，在对象真正用到这些相互关联的属性时再抛出异常。
	* 避免在属性的getter中抛出异常。如果属性的setter抛出异常，要保留属性原来的值。
* 要把构造函数的参数列表当做设置主要属性的快捷方式。
	* 无论是使用空的构造函数并随后设置一些属性，还是使用具有多个参数的构造函数，两者之间不应该有任何差异。
	* 要用相同的名字来命名构造函数的参数和属性——如果定义该构造函数的目的就是为了设置对应的属性。
	* 要在构造函数中做最少的工作。除了把构造函数的参数保存下来之外，构造函数不应该执行太多的操作。应尽可能把其他处理所引起的开销推迟到真正需要的时候。
* 要在适当的时候从实例构造函数中抛出异常，但要妥善处理。当构造函数抛出异常时，虽然new操作符并不返回对象的引用，但事实上对象已经创建了。如果类型定义了Finalize方法，那么垃圾收集器在回收对象时会调用该方法。也就是说我们应该确保部分构造的对象也能运行Finalize方法。另外，如果一个构造函数过早地把this引用传出去，那么即使它在构造完成之前抛出异常，该对象仍然可能会被外界访问。
* C# 之所以不允许在结构中显式地定义默认构造函数，是因为如果没有定义默认构造函数，那么运行库就不必为数组中的每个元素调用构造函数，而只需要分配内存并按位初始化就可以了。
* 避免在对象的构造函数内部调用虚成员。否则构造派生类时，在其定义的构造函数代码被执行之前，被其重写的虚成员可能会被父类的构造函数调用到。而此时，派生类可能尚未做好虚成员被调用的准备。
* 确保不要在静态构造函数中抛出异常。如果某个类型的静态够咱函数抛出异常，那么该类型就不能在当前的应用程序域中使用了。
* 所谓事件，实际上就是一个类型为委托的字段，在加上两个对该字段进行操控的方法。
* 对于非密封类中的非静态事件，应该用受保护的虚方法来触发它。目的是为了为派生类提供一种方法，让它们能够通过覆盖虚方法来处理该事件。根据约定，方法的名字应该以“On”开头，随后是事件的名字。
* 不要提供公有的或受保护的实例字段。不直接把字段暴露出来，我们可以得到更多的灵活性。原因如下：
	* 在保证二进制兼容性的前提下把字段改成属性是不可能的。
	* 由于属性的get和set中存在可执行的代码，因此能够在以后对属性的使用进行改进。
* 考虑在下面的场景使用扩展方法：
	* 为一个接口的所有实现提供相关的辅助功能，而且这些功能可以通过核心接口来表达。
	* 如果增加一个实例方法会引入对其他类型的依赖关系,而该依赖关系会破坏依赖关系的管理规则,那么应该使用扩展方法。

## 第6章·扩展性设计
* 避免将公有成员设计为虚成员。公有成员应该通过调用受保护的虚成员的方式来提供扩展性。类的公有成员应该为类的直接使用者提供正确的功能集。
* 避免在命名基类时使用“Base”后缀——如果公用API中会用到这个类。例如，尽管`Collection<T>`的设计目的是供其他类派生的，但是在许多情况下，框架暴露的API仍然会用到它。此时，如果`Collection<T>`被命名为`CollectionBase<T>`，那么暴露`Collection<T>`的框架API就会很难看了。

## 第7章·异常
* 与使用返回值来报告错误的机制相比，异常处理机制有这些优势:
	* 异常与各种面向对象语言集成得非常好。面向对象语言经常对约束成员的签名加以限制，例如以构造函数、操作符重载及属性为例，开发人员不能选择错误码作为其返回值。在这种情况下,只能选择使用异常来报告错误。
	* 异常增强了API的一致性。这是因为设计异常的唯一目的就是为了用来报告错误。所以，仅使用异常来报告错误的API具有相当固定的模式。
	* 在用返回值来报告错误时，错误处理的代码与可能发生错误的代码距离总是很近。
	* 错误代码很容易被忽略，而且经常会被忽略。异常机制则使得开发人员无法忽略未处理的异常。
	* 异常可以包含丰富的信息来对错误的原因加以描述。
	* 异常更易于调试。
* 考虑使用辅助方法来生成异常对象。
	*  从不同的地方抛出同一个异常是很常见的，为了避免代码重复，可以使用辅助函数来生成异常对象并对其属性进行初始化。
	* 另外，抛出异常的成员无法被内联，如果把抛出异常的语句移到辅助函数中，那么该成员就有可能被内联。
* 程序中的错误可以被分为使用错误和执行错误两类。
	* 使用错误说明程序写的不正确，可以通过修改调用API的代码来加以避免。例如如果一个函数由于传给它的某个参数为null而进入错误状态，那么应该通知调用方代码，让它保证不会再在参数中传入null。换句话说，开发人员可以在编译的时候修正使用错误，并保证这样的错误在运行的时候绝对不会发生。
	* 执行错误是那些无法通过编写“更好的”代码来加以避免的错误。例如，`File.Open`在视图打开一个不存在的文件时会抛出FileNotFoundException。即使代码在调用File.Open之前检查了文件是否存在，该文件仍然有可能会在调用`File.Exists`和`File.Open`之间被删除或破坏。
* 可以把执行错误进一步分为两类：程序错误和系统失败。
	* 程序错误是那些可以在程序中处理的执行错误。例如，如果File.Open抛出FileNotFoundException，那么调用代码可以捕获该异常并创建一个新文件，从而完成对它的处理。
	* 系统失败是那些无法在程序中进行处理的执行错误。例如，如果jit用尽了内存而引发OutOfMemoryException，那么这类异常就是应用程序无法处理的。
* 不要为了通报使用错误而创建新的异常类型。在这种情况下一概抛出框架中已有的异常。
* 不应该在代码中直接处理使用错误，而应该把使用错误通报给调用API的代码。
* 不要仅仅为了拥有自己的异常而创建并使用新的异常。
* 要在捕获并重新抛出异常时使用空的throw语句。这是保持异常调用栈不变的最好方法。
* 要重写自定义异常的ToString方法。

## 第8章·使用规范
* 考虑使用不规则数组，而不要使用多维数组。不规则数组比多为数组节省许多空间。此外，CLR对于不规则数组的索引操作进行了优化。
* 不要在公有API中使用`ArrayList`和`List<T>`，而应使用`Collection<T>`或`ICollection<T>`。
* 不要在公有API中使用`Hashtable`和`Dictionary<Tkey, TValue>`，而应使用`IDictionary<Tkey, TValue>`。
* 避免使用`ICollection<T>`来做参数，而应使用`IEnumerable<T>`。
* 不要让属性返回快照集合,属性应该返回实况集合。
* 要用快照集合或实况的`IEnumerable<T>`(或它的子类)来表示不稳定的集合(也就是说,无需显式地修改就可能会发生改变的集合)。
* 不要从集合属性或以集合为返回值的方法中返回null。而要返回一个空集合或空数组。
* 在高层API的公有属性和方法返回值设计中，要优先使用集合,而不是优先使用数组。
	* 集合对其内容有更好的控制，能够随时间而演化,而且更易于使用。此外，由于复制数组的代价令人望而却步,因此我们反对将数组用于制度的情况。可用性研究显示,有些开发人员在使用基于集合的API是感觉更好。
	* 但是，如果正在开发的是底层API，那么在需要可读写的情况下使用数组可能会更好。数组对内存的消耗比较少，这有助于减少工作集。另外访问数组中的元素也更快,这是由于运行库对它做了优化。
* 要为值类型重写`Equals`方法，并考虑实现`IEquatable<T>`。值类型的`Object.Equals`方法会导致装箱操作,而且因为它的默认实现使用了反射,所以效率不高。`IEquatable<T>`可以提供好得多的性能,而且如果实现得当,可以完全避免装箱操作。
* 不要从`Equals`方法中抛出异常`。
* 如果重写了`Object.Equals`方法，就要重写`GetHashCode`方法。要确保对任何两个对象来说，如果`Object.Equals`方法返回true,那么它们的G`etHashCode`方法的返回值也应该相同。如果`obj1.Equals(obj2)`返回true，那么这两个对象应该具有相同的散列码。如果对象不相等，那么它们的散列码可能相同，也可能不同。
* 要确保无论怎么更改对象，GetHashCode都会返回完全相同的值。所以对于可变的值类型，不建议实现值相等语义。
* API不要用`XmlNode`或`XmlDocument`作为返回值或参数。要尽量使用`IXPathNavigable`、`XmlReader`、`XmlWriter`或`XNode`的子类型。

## 第9章·常用设计模式
* 一条重要的API设计原则就是，要么完全隐藏复杂性（或几乎完全隐藏），要么根本就不隐藏。最糟糕的情况就是设计一个看上去简单的API，但当开发人员开始使用的时候，却发现事实并非如此。
* 面向组件设计是一种设计方法，它通过类型来暴露API，而类型则由构造函数、属性、方法及事件组成。
	* 这种方法不仅仅是把构造函数、方法、属性及事件放在一起，它更注重API的使用方式。面向组件的设计遵循一定的使用模式：先用默认的或相对简单的构造函数来实例化一个类型，然后设置实例的一些属性，最后调用实例的一些方法。我们称这种模式为Create-Set-Call使用模式。
	* 面向组件设计的一个问题是它有时候会使类型处于无效的状态。
